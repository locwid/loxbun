import { mkdir } from "fs/promises";

const defineVisitor = (
	writer: Bun.FileSink,
	baseName: string,
	types: string[],
) => {
	writer.write(`export interface ${baseName}Visitor<T> {\n`);
	for (const type of types) {
		const [className] = type.split("->");
		writer.write(
			`\tvisit${className?.trim()}${baseName}(${className?.trim().toLowerCase()}: ${className?.trim()}${baseName}): T;\n`,
		);
	}
	writer.write("}");
};

const defineType = (
	writer: Bun.FileSink,
	baseName: string,
	className: string,
	fields: string,
) => {
	writer.write(
		`export class ${className.trim()}${baseName} extends ${baseName} {\n`,
	);
	for (const field of fields.split(",")) {
		const [name, type] = field.split(":");
		writer.write(`\t${name?.trim()}: ${type?.trim()};\n`);
	}
	writer.write("\n");
	writer.write(`\tconstructor(${fields.trim()}) {\n`);
	writer.write(`\t\tsuper();\n`);
	for (const field of fields.split(",")) {
		const [name] = field.split(":");
		writer.write(`\t\tthis.${name?.trim()} = ${name?.trim()};\n`);
	}
	writer.write("\t}\n\n");
	writer.write(`\taccept<T>(visitor: ${baseName}Visitor<T>): T {\n`);
	writer.write(
		`\t\treturn visitor.visit${className?.trim()}${baseName}(this);\n`,
	);
	writer.write("\t}\n");

	writer.write(`}\n\n`);
};

const defineAst = async (
	outDir: string,
	baseName: string,
	types: string[],
	imports: string[] = [],
) => {
	const filePath = `${outDir}/${baseName}.ts`;
	await Bun.file(filePath).delete().catch();
	await mkdir(outDir, { recursive: true });
	const file = Bun.file(`${outDir}/${baseName}.ts`);
	const writer = file.writer();

	writer.write("//\n");
	writer.write("// THIS FILE GENERATED BY CODEGEN, DO NOT EDIT IT\n");
	writer.write("//\n\n");
	for (const imp of imports) {
		writer.write(`${imp};\n`);
	}
	writer.write("\n");
	defineVisitor(writer, baseName, types);
	writer.write("\n\n");
	writer.write(`export abstract class ${baseName} {\n`);
	writer.write(`\tabstract accept<T>(visitor: ${baseName}Visitor<T>): T;\n`);
	writer.write("}\n");

	for (const t of types) {
		const [className, fields] = t.split("->");
		if (!className || !fields) {
			console.error(`Invalid type definition: ${t}`);
			process.exit(65);
		}
		defineType(writer, baseName, className, fields);
	}
};

const args = Bun.argv;

if (!args[2] || args.length > 3) {
	console.log("Usage: ast <output directory>");
	process.exit(64);
}

defineAst(
	args[2],
	"Expr",
	[
		"Assign   -> name: Token, value: Expr",
		"Binary   -> left: Expr, operator: Token, right: Expr",
		"Grouping -> expression: Expr",
		"Literal  -> value: unknown",
		"Logical  -> left: Expr, operator: Token, right: Expr",
		"Unary    -> operator: Token, right: Expr",
		"Variable -> name: Token"
	],
	["import { Token } from 'src/Token';"],
);

defineAst(
	args[2],
	"Stmt",
	[
		"Block      -> statements: Stmt[] = []",
		"Expression -> expression: Expr", 
		"Condition  -> condition: Expr, thenBranch: Stmt, elseBranch: Stmt | null",
		"Print      -> expression: Expr", 
		"Variable   -> name: Token, initializer: Expr | null",
		"WhileLoop  -> condition: Expr, body: Stmt",
	],
	[
		"import { Expr } from './Expr';", 
		"import { Token } from 'src/Token';"
	],
);
